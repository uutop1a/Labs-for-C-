Лабораторная №1
№1.1
Дана сигнатура функции: double fraction (double x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
только дробную часть числа х. Подсказка: вещественное число может быть 
преобразовано к целому путем отбрасывания дробной части.
test: Enter x:5.34223
Separated part:0.34223
Алгоритм разделения числа использует функцию modf() из библиотеки math.h для разделения числа на целую и дробную части

№1.3
Дана сигнатура функции: int charToNum (char x);
Функция принимает символ х, который представляет собой один из “0 1 2 3 4 5 
6 7 8 9”. Необходимо реализовать функцию таким образом, чтобы она
преобразовывала символ в соответствующее число. Подсказка: код символа ‘0’ 
— это число 48.
test: Enter x:5
Char into number:5
Функция charToNum() принимает символ цифры, вычитает код символа "0" (ASCII 48) и возвращает соответствующее число

№1.5
Дана сигнатура функции: bool is2Digits (int x);
Необходимо реализовать функцию таким образом, чтобы она принимала число 
x и возвращала true, если оно двузначное.
test: Enter x:57
true
Алгоритм анализирует вводимое пользователем число и проверяет его на прилегание к диапазону -100 ≤ x ≤ -10 и 10 ≤ x < 100

№1.7
Дана сигнатура функции: bool isInRange (int a, int b, int num);
Функция принимает левую и правую границу (a и b) некоторого числового 
диапазона. Необходимо реализовать функцию таким образом, чтобы она 
возвращала true, если num входит в указанный диапазон (включая границы). 
Обратите внимание, что отношение a и b заранее неизвестно (неясно кто из них 
больше, а кто меньше)
test:Enter a:3
Enter b:7
Enter x:4
true
Алгоритм посредством исключения определяет какое число больше, и проверяет лежит ли Х в этом диапазоне

№1.9
Дана сигнатура функции: bool isEqual(int a, int b, int c);
Необходимо реализовать функцию таким образом, чтобы она возвращала true, 
если все три полученных функцией числа равны
test: Enter a:4
Enter b:4
Enter c:4
true
Алгоритм проверяет равны ли все числа и возвращает true, если это так

№2.1
Дана сигнатура функции: int abs (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
модуль числа х (если оно было положительным, то таким и остается, если он 
было отрицательным – то необходимо вернуть его без знака минус)
test:Enter a:-6
6
Алгоритм проверяет положительен ли Х, если да, то возвращает его без изменений, если Х отрицательный то возвращает число с обратным знаком

№2.3
Дана сигнатура функции: bool is35 (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала true, 
если число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на 
5, то вернуть надо false. Подсказка: оператор % позволяет получить остаток от 
деления.
test:Enter a:45
false
Enter a:50
true
Алгоритм проверяет делимость числа на 3 и 5, и если условие не соблюдается то проверяет делимость отдельно

№2.5
Дана сигнатура функции: int max3 (int x, int y, int z);
Необходимо реализовать функцию таким образом, чтобы она возвращала
максимальное из трех полученных функцией чисел. Подсказка: идеальное 
решение включает всего две инструкции if и не содержит вложенных if.
test:Enter x:5
Enter y:4
Enter z:8
The max number is:8
Алгоритм устанавливает переменную max, равное первому числу, и сравнивает его со вторым и с третьим, и если какое то число больше переменной max, то 
оно устанавливается заново, а в конце функции выводится

№2.7
Дана сигнатура функции: int sum2 (int x, int y);
Необходимо реализовать функцию таким образом, чтобы она возвращала
сумму чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо 
вернуть число 20.
test:Enter x:3
Enter y:4
7
Enter x:5
Enter y:13
20
Алгоритм суммирует числа, и проверяет их во вхождение в диапазон от 10 до 19, в таком случае он возвращает 20

№2.9
Дана сигнатура функции: String day (int x);
Функция принимает число x, обозначающее день недели. Необходимо 
реализовать функцию таким образом, чтобы она возвращала строку, которая 
будет обозначать текущий день недели, где 1 — это понедельник, а 7 –
воскресенье. Если число не от 1 до 7 то верните текст “это не день недели”. 
Вместо if в данной задаче используйте switch.
test:Enter x:5
Friday
Алгоритм принимает число Х и конструкцией switch сравнивает число с установленными числами дней недели, и возвращает день недели, у которого привязанное число совпадает с Х

№3.1
Дана сигнатура функции: String listNums (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
строку, в которой будут записаны все числа от 0 до x (включительно)
test:Enter x:87
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
 81 82 83 84 85 86 87
Алгоритм инициализирует цикл от 0 до X: для каждого числа i преобразует число в строку и добавляет его к результату, после чего добавляет пробел, если число не последнее и возвращает готовую строку

№3.3
Дана сигнатура функции: String chet (int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
строку, в которой будут записаны все четные числа от 0 до x (включительно). 
Подсказа для обеспечения качества кода: инструкцию if использовать не 
следует.
test:Enter x:25
0 2 4 6 8 10 12 14 16 18 20 22 24
Алгоритм использует функцию как в задании №3.3, но использует шаг i=2


№3.5
Дана сигнатура функции: int numLen (long x);
Необходимо реализовать функцию таким образом, чтобы она возвращала
количество знаков в числе x. 
Подсказка:
Int у=123/10; // у будет иметь значение 12
test:Enter x:443..\\23
9
Алгоритм берет вводимую пользователем строку и вычисляет ее длинну 

№3.7
Дана сигнатура функции: void square (int x);
Необходимо реализовать функцию таким образом, чтобы она выводила на 
экран квадрат из символов ‘*’ размером х, у которого х символов в ряд и х 
символов в высоту
test:Enter x:4
****
****
****
****
Алгоритм с двумя циклами, один из которых считает звездочки, а другой считает пробелы и делает отступы

№3.9
Дана сигнатура функции: void rightTriangle (int x);
Необходимо реализовать функцию таким образом, чтобы она выводила на 
экран треугольник из символов ‘*’ у которого х символов в высоту, а количество 
символов в ряду совпадает с номером строки, при этом треугольник выровнен 
по правому краю. Подсказка: перед символами ‘*’ следует выводить 
необходимое количество пробелов.
test:Enter x:4
   *
  **
 ***
****
Всё как в задании 3.7

№4.1
Дана сигнатура функции: int findFirst (int arr[], int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала индекс 
первого вхождения числа x в массив arr. Если число не входит в массив –
возвращается -1.
test:Enter count of symbols in arr:4
Enter x:3
Enter numbers by Enter:
1
Enter numbers by Enter:
2
Enter numbers by Enter:
3
Enter numbers by Enter:
5
Found index:2
Алгоритм создает массив введенный пользователем, и проходится по нему в поисках Х, если Х не обнаружен, то возвращается -1

№4.3
Дана сигнатура функции: int maxAbs (int arr[]);
Необходимо реализовать функцию таким образом, чтобы она возвращала
наибольшее по модулю (то есть без учета знака) значение массива arr.
test:Enter count of symbols in arr:5
 Enter number 1:1
 Enter number 2:2
 Enter number 3:-58
 Enter number 4:43
 Enter number 5:12
 Found number: -58
Алгоритм устанавливает первое число массива как максимальное, далее он сравнивает максимальное число с другими по модулю, и возвращает максимальный результат

№4.5
Дана сигнатура функции: int * add (int arr[], int ins[], int pos);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый 
массив, который будет содержать все элементы массива arr, однако в позицию pos
будут вставлены значения массива ins.
test:Result: 1 2 3 7 8 9 4 5
Алгоритм создает новый массив размером arrSize + insSize, копирует три части: элементы до позиции вставки, вставляемый массив и оставшиеся элементы массива, а после возвращает получившийся массив

№4.7
Дана сигнатура функции: int * reverseBack (int arr[]);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый 
массив, в котором значения массива arr записаны задом наперед.
test:Result: 5 4 3 2 1
Алгоритм создает пустой вектор reversed, проходит исходный массив с конца и добавляет элементы в новый вектор в обратном порядке

№4.9
Дана сигнатура функции: int * findAll (int arr[], int x);
Необходимо реализовать функцию таким образом, чтобы она возвращала новый 
массив, в котором записаны индексы всех вхождений числа x в массив arr.
test:Enter count symbols in arr:5
Enter x:1
Enter numbers by Enter:
2
Enter numbers by Enter:
3
Enter numbers by Enter:
1
Enter numbers by Enter:
1
Enter numbers by Enter:
5
Founded elements:
2 3
Алгоритм проходит по массиву, находит все индексы, где встречается Х, сохраняя их в отдельный массив

Лабораторная №2

№1.1
Дан текстовый файл с именем name, содержащий строковые представления целых чисел.
Заполнить вектор V числами из исходного файла и вывести элементы вектора в исходном
порядке.
test: name: 1 2 3 4 5
Vector elements: 1 2 3 4 5
Алгоритм проходится по каждому элементу файла и заполняет вектор V

№2.6
Даны вектор V и дек D, имеющие четное количество элементов. Добавить в конец вектора
первую половину элементов дека (в исходном порядке), а в начало дека — вторую половину
исходных элементов вектора (в обратном порядке). Использовать два вызова функции-члена
insert.
test: Enter the number of vector elements (even number): 4
Enter vector elements: 1 2 3 4
Enter the number of deque elements (even number): 4
Enter deque elements: 5 6 7 8
Vector elements: 1 2 3 4 5 6 
Deque elements: 4 3 5 6 7 8 
Алгоритм создает временные контейнеры и возвращает уже готовые массив и дек

№3.8
Дан вектор V. Удалить все элементы исходного вектора с нечетными порядковыми номерами
(считая, что начальный элемент вектора имеет порядковый номер 1). Использовать функцию-
член erase в циклес параметром-итератором.
Указание. Организуйте перебор элементов вектора в цикле с параметром-итератором i,
увеличивая параметр в заголовке цикла. Удаление выполняйте в позиции i, обязательно
присваивая параметру i значение, возвращаемое функцией-членом erase.В конце каждой
итерации цикла дополнительно проверяйте, достигнут ли конец вектора.
test:Enter the number of vector elements (positive number): 4
Enter vector elements: 12 24 65 1
Vector after removing elements with odd ordinal numbers:
Vector elements: 24 1 
Алгоритм чистит позиции которые при делении на 2 дают остаток, проходя по массиву и очищая символы методом erase()

№4.2
Дан текстовый файл с именем name, содержащий строковые представления целых чисел.
Вывести числа из исходного файла с нечетными порядковыми номерами (т. е. первое число,
третье число и т. д.). Использовать алгоритм remove_copy_if.
test:Enter the number of integers:6
Enter 6 integers: 1 2 3 4 5 6
Numbers with odd ordinal numbers: 1 3 5 
Алгоритм проходит по файлу или заданному вектору и определяет является ли индекс числа нечетным, если он возвращает true, то число удаляется

№5.9
Дано целое число K (> 0) и вектор V. Продублировать в векторе V первый набор из K подряд
расположенных положительных чисел, вставив после этого набора его копию (если в наборе
имеется больше K положительных чисел, то лишние числа во внимание не принимаются, и
дублируется только начальная часть набора, содержащая K чисел). Если вектор не содержит
требуемого набора чисел, то не изменять его. Использовать алгоритм search_n с параметром —
функциональным объектом.
test:Enter the number of vector elements (positive integer):5
 Enter vector elements:1 2 3 4 5
 Enter K (number of consecutive positive n
umbers):4
Vector after duplicating first K positive numbers:
1 2 3 4 1 2 3 4 5
Алгоритм проходит по списку и находит число К, после которого дублирует весь список

№6.9
Даны списки L1 и L2, каждый из которых содержит четное количество элементов. В каждом 
списке продублировать первую половину, добавив ее элементы в конец списка в обратном 
порядке. Для первого списка использовать алгоритм reverse_copy и итератор вставки, для 
второго — функцию-член insert и обратные итераторы. Использовать также функцию advance.
Замечание. Второй способ является более эффективным.
test:Enter count of elements (even):4
 Enter 4 int numbers:
1 2 3 4
Result L1: 1 2 3 4 2 1
Enter count of elements (even):6
 Enter 6 int numbers:
1 2 3 4 5 6
Result L2: 1 2 3 4 5 6 3 2 1
Алгоритм делит списки на две равные части, после чего разворачивает первую и копирует ее в конец списка

№7.6
Дан список L. Перегруппировать элементы списка, расположив в нем вначале положительные, а 
затем неположительные элементы (порядок расположения элементов в каждой группе должен 
совпадать с исходным). Использовать алгоритм stable_partition.
test: Enter 7 even numbers:
1 2 3 -12 422 -832 12
Result:
1 2 3 422 12 -12 -832
Алгоритм читает список чисел, переупорядочивает элементы - все положительные в начало, неположительные в конец, сохраняет порядок элементов и выводит результат

№8.2
Дан список L, элементами которого являются английские слова. Получить дек D со строковыми 
элементами, каждый из которых строится по паре соседних элементов исходного списка L
следующим образом: последняя буква правого элемента пары приписывается справа к первой 
букве левого элемента пары. Количество элементов дека D должно быть на 1 меньше 
количества элементов списка L. Например, для исходного списка ABC, DEF, KLM, XYZ
полученный дек должен содержать строки AF, DM, KZ. Использовать алгоритм 
adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член 
erase для дека D.
test:Enter a count of words in list L:6
 Enter 6 english words:
ADF NBS YTS NAM ESB THE
List L:
ADF NBS YTS NAM ESB THE
Dec D:
AS NS YM NB EE
Алгоритм читает список, создает дек из комбинаций первых и последних букв соседних слов, формирует новые слова, и выводит результат в дек

№9.1
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0 
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, 
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать 
алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе 
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 
1, …, N.
test:Enter V0:
Enter a count of vector's elements:3
 Enter 3 positive numbers:
2 5 3
Enter a count of vectors N (> 0):3
Enter V1:
Enter a count of vector L1:6
 Enter 6 positive numbers:
1 2 3 4 5 6
Enter V2:
Enter a count of vector L2:3
 Enter 3 positive numbers:
2 3 7
Enter V3:
Enter a count of vector L3:4
 Enter 4 positive numbers:
5 3 2 8
Vi, containing elements V0: 2
Алгоритм читает векторы и проверяет все векторы I на содержание элементов из V0, в конце считает количество векторов соблюдающих условие, и выводит результат
    Читает эталонный вектор V0 и N дополнительных векторов от пользователя

№10.1
Дан вектор V. Определить количество повторений каждого числа в векторе V и вывести все 
различные элементы вектора V вместе с количеством их повторений (в порядке возрастания 
значений элементов); количество повторений выводить сразу после значения 
соответствующего элемента. Использовать вспомогательное отображение M (класс map), 
ключами которого являются различные элементы вектора V, а значениями — количество 
повторений этих элементов. При заполнении отображения M не использовать условные 
конструкции (достаточно операций индексирования [] и инкремента). Элементы вектора V (при 
заполнении отображения M) и элементы отображения M (при выводе полученных результатов) 
перебирать в цикле с параметром-итератором соответствующего контейнера
test:Enter a count of numbers in vector:7
 Enter 7 positive numbers:
1 2 2 3 3 3 4
Elements of vector and count of their repetitions:
1 1
2 2
3 3
4 1
Алгоритм читает вектор, подсчитывает количество вхождений каждого элемента в векторе, использует map() для хранения данных и выводит статистику о повторениях

Лабораторная №4

№4.1
Реализовать определение класса (поля, свойства, конструкторы (не менее трех), 
перегрузку оператора вывода для вывода полей, заданный метод согласно варианту). 
Протестировать все методы, включая конструкторы, все исходные данные вводятся с клавиатуры, не 
забывайте проверять данные на корректность.
Название класса: Point
Поля: double x, double y
Методы: Вычислить расстояние от точки до начала 
координат. Результат должен быть типа double.

Создание поля с точками Х и У. Действующие конструкторы: Конструктор по умолчанию(0:0), Конструктор с параметрами (создание точек), Копирующий конструктор (копия существующей точки)
Метод вычисляет расстояние от точки до начала координат (0,0) по формуле sqrt(x^2+y^2). Сеттер позволяет менять координаты точки. Оператор вывода перегружен (<<), чтобы объект Point можно было удобно выводить через cout.

№4.2
Добавить к реализованному в первом задании классу указанные в варианте перегруженные операции. 
В главной функции main показать работу всех функций с дружественным интерфейсом
Унарные операции:
--уменьшить координаты x и y на 1;
- поменять координаты х и у местами.
Операции приведения типа:
int (неявная) – результатом является целая часть координаты х;
double (явная) – результатом является координата y.
Бинарные операции:
– целое число – уменьшается координата х;
– Point p – вычисляется расстояние до точки p, результатом должно быть вещественное число
​
Перегруженные операторы:
Унарные операции:
--p (уменьшает Х и У на 1)
-р (возвращает новую точку, где Х и У поменяны местами)
Приведение типов:
Неявное приведение к int - возвращает целую часть координаты Х
Явное приведение к double - возвращает координату У
 Бинарные операции:
Point - int (уменьшает координату Х на заданное число)
Point - Point (возвращает расстояние между двумя точками)
Оператор вывода перегружен (<<), чтобы объект Point можно было удобно выводить через cout.

Тест: 
Enter x for p1:4
 Enter y for p1:3
 Enter x for p2:0
 Enter y for p1:1

-----------------------------
Current points:
p1 = Point(x=4, y=3)
p2 = Point(x=0, y=1)
-----------------------------
1) --p1 (decrease x and y p1 by 1)
2) -p1 (swap x and y, return the NEW point)
3) Implicit cast of p1 to int (integer part of x)
4) Explicit cast of p1 to double (y coordinate)
5) p1 - k (decrease x by an integer k, return the NEW point)
6) p1 - p2 (distance between points)

1)  Completed: --p1
Now p1 = Point(x=3, y=2)

2)  Result -p1 (p1 does NOT change)): Point(x=2, y=3)
p1 as he was, he remained: Point(x=3, y=2)

3) int(p1) implicitly: 3 (whole part x)

4) (double)p1 clearly: 2 (this is y)

5) Enter an integer k:4
 p1 - 4 = Point(x=-1, y=2) (p1 does not change)

6)  Distance p1 - p2 = 3.16228









